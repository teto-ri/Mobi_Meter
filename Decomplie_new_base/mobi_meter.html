<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>모비노기 전투분석기</title>
    <style>
        body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #1a1a1a;
    color: #ffffff;
    margin: 0;
    padding: 20px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 0 20px;
}

.header {
    text-align: center;
    margin-bottom: 30px;
    padding: 20px;
    background: linear-gradient(135deg, #2c3e50, #34495e);
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.header h1 {
    margin: 0;
    font-size: 2.5em;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.battle-info {
    display: flex;
    justify-content: space-between;
    margin-top: 15px;
    font-size: 1.1em;
}

.player-rankings {
    background-color: #2c2c2c;
    border-radius: 10px;
    padding: 20px 30px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.ranking-header {
    display: grid;
    grid-template-columns: 60px 1fr 200px;
    gap: 15px;
    padding: 15px 20px;
    background-color: #34495e;
    border-radius: 8px;
    margin-bottom: 20px;
    font-weight: bold;
    font-size: 0.9em;
    color: #ecf0f1;
}

.ranking-header > div:last-child {
    text-align: right;
}

.player-bar {
    margin-bottom: 12px;
    position: relative;
    background-color: #4a4a4a;
    border-radius: 8px;
    overflow: visible;
    height: 50px;
    transition: all 0.3s ease;
}

.player-bar-content {
    display: grid;
    grid-template-columns: 60px 1fr 200px;
    gap: 15px;
    align-items: center;
    position: relative;
    z-index: 2;
    height: 100%;
    padding: 0 7px;
}

.player-bar:hover {
    transform: translateX(5px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.rank-section {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 10px;
}

.rank-number {
    background-color: #34495e;
    color: #ecf0f1;
    border-radius: 50%;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1em;
    font-weight: bold;
}

.rank-1 { background: linear-gradient(135deg, #f1c40f, #f39c12); color: #2c3e50; }
.rank-2 { background: linear-gradient(135deg, #95a5a6, #bdc3c7); color: #2c3e50; }
.rank-3 { background: linear-gradient(135deg, #e67e22, #d35400); color: white; }


.player-bar-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: linear-gradient(90deg, #3498db, #2980b9);
    transition: width 0.5s ease;
    border-radius: 8px;
    z-index: 1;
}

.player-bar-fill.top-player {
    background: linear-gradient(90deg, #e74c3c, #c0392b);
}

.player-bar-fill.high-dps {
    background: linear-gradient(90deg, #27ae60, #229954);
}

.player-bar-fill.crit-master {
    background: linear-gradient(90deg, #f39c12, #e67e22);
}

.player-name {
    font-weight: bold;
    font-size: 1em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    color: #ffffff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding-left: 15px;
    display: flex;
    align-items: center;
}

.stat-value {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    font-weight: bold;
    font-size: 0.95em;
    text-align: right;
    padding: 0 5px;
}

.damage-value {
    color: #ffffff;
}

.dps-value {
    color: #ffffff;
}

.percentage-value {
    color: #f39c12;
}

.connection-status {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 10px 15px;
    border-radius: 5px;
    font-weight: bold;
    z-index: 1000;
}

.connected {
    background-color: #27ae60;
    color: white;
}

.disconnected {
    background-color: #e74c3c;
    color: white;
}

.no-data {
    text-align: center;
    color: #7f8c8d;
    font-size: 1.2em;
    margin: 50px 0;
}

.updating {
    /* No animation - removed flashing effect */
}

.player-details {
    font-size: 0.8em;
    color: #bdc3c7;
    margin-top: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.player-bar {
    cursor: pointer;
}

.player-bar:active {
    transform: translateX(3px);
}

.skill-breakdown {
    background-color: #3a3a3a;
    border-radius: 8px;
    margin-top: 10px;
    padding: 15px;
    border-left: 4px solid #3498db;
    display: none;
}

.skill-breakdown.show {
    display: block;
}

.skill-breakdown.show.animate {
    animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
    from {
        opacity: 0;
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    to {
        opacity: 1;
        max-height: 500px;
        padding-top: 15px;
        padding-bottom: 15px;
    }
}

.skill-breakdown-header {
    font-size: 1.2em;
    font-weight: bold;
    margin-bottom: 15px;
    color: #3498db;
}

.skill-item {
    background-color: #4a4a4a;
    border-radius: 4px;
    margin-bottom: 8px;
    overflow: hidden;
}

.skill-item-bar {
    position: relative;
    height: 30px;
    border-radius: 4px;
    overflow: hidden;
}

.skill-item-fill {
    height: 100%;
    background: linear-gradient(90deg, #e74c3c, #c0392b);
    transition: width 0.3s ease;
    border-radius: 4px;
    position: absolute;
    top: 0;
    left: 0;
}

.skill-item-fill.crit-heavy {
    background: linear-gradient(90deg, #f39c12, #e67e22);
}

.skill-item-fill.top-skill {
    background: linear-gradient(90deg, #9b59b6, #8e44ad);
}

.skill-item-info {
    position: relative;            /* ✅ 기준 컨테이너로 만듦 */
    height: 100%;
    display: block;                /* ✅ 수직 겹침 허용 */
    overflow: visible;
}

.skill-name {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1em;
    font-weight: 600;
    color: #fff;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    white-space: nowrap;
    overflow: visible;
    z-index: 1;
}

.skill-compact-stats {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.4);
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.85em;
    font-weight: bold;
    color: #ccc;
    white-space: nowrap;
    text-shadow: 1px 1px 1px #000;
    z-index: 2;
}

.skill-basic-stats .highlight-percent {
    color: #1abc9c;
    font-weight: bold;
    font-size: 1.2em;
}

.skill-item-stats-block {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 4px 10px;
    font-size: 0.85em;
    background-color: #3a3a3a;
    border-radius: 0 0 4px 4px;
    margin-bottom: 2px;
}


.skill-basic-stats {
    flex-shrink: 0;
    color: #ccc;
    white-space: nowrap;
    font-size: 1em;
    align-self: center;
    font-weight: bold;
}

.skill-extra-stats {
    flex-shrink: 1;
    font-size: 0.75em;
    display: flex;
    justify-content: flex-end;
    color: #ccc;
}

.stats-table {
    border-collapse: collapse;
    background-color: #2e2e2e;
    border: 1px solid #555;
    border-radius: 4px;
    overflow: hidden;
}

.stats-table td {
    padding: 4px 6px;
    border: 1px solid #555;
    white-space: nowrap;
    font-size: 0.75em;
}



.raw-logs {
    margin-top: 40px;
    background-color: #2c2c2c;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    max-height: 400px;
    overflow: hidden;
}

.raw-logs h2 {
    font-size: 1.3em;
    color: #1abc9c;
    margin-bottom: 15px;
    text-align: center;
}

#log-output {
    background-color: #111;
    color: #0f0;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.5;
    padding: 10px;
    border-radius: 5px;
    overflow-y: auto;
    max-height: 300px;
    white-space: pre-wrap;
    word-break: break-word;
    border: 1px solid #333;
}

.timing-stats {
    font-size: 11px;
    color: #aaa;
    margin-top: 4px;
}

#damageChart {
    width: 100%;
    max-width: 800px;
    height: 400px;
    background-color: #1a1a1a;
    margin: 20px auto;
    border: 1px solid #333;
}

#chart-empty-overlay {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: none;
  align-items: center;
  justify-content: center;
  color: #aaa;
  font-size: 1.2em;
  font-weight: bold;
  background-color: rgba(26, 26, 26, 0.8);
  pointer-events: none;
  z-index: 10;
}


#sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 240px;
  height: 100vh;
  background-color: #2c3e50;
  color: white;
  padding: 20px 10px;
  box-shadow: 2px 0 8px rgba(0,0,0,0.4);
  overflow-y: auto;
  z-index: 999;
  transform: translateX(0);
  transition: transform 0.3s ease;
}


#sidebar.hidden {
  transform: translateX(-100%);
}


#sidebar-toggle {
  position: fixed;
  top: 20px;
  left: 250px; /* default when sidebar is visible */
  z-index: 1001;
  background-color: #34495e;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 6px 0 0 6px;
  cursor: pointer;
  box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
  transition: left 0.3s ease, background-color 0.3s ease;
}


.sidebar-collapsed #sidebar-toggle {
  left: 0; /* shift button to screen edge when sidebar is hidden */
  border-radius: 0 6px 6px 0;
}


#sidebar h2 {
    font-size: 1.2em;
    margin-bottom: 15px;
    text-align: center;
}

#battle-history-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

#battle-history-list li {
    cursor: pointer;
    padding: 10px;
    margin-bottom: 6px;
    background-color: #34495e;
    border-radius: 5px;
    font-size: 0.9em;
    transition: background 0.3s;
}

#battle-history-list li:hover {
    background-color: #3d5d78;
}

.capture-area {
    background-color: #1a1a1a;  /* 어두운 배경 */
    color: #ffffff;
    padding: 20px;
    border-radius: 12px;
    width: fit-content;
    max-width: 100%;
}

#floating-controls {
    position: fixed;
    top: 100px;
    right: 20px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 20px;
}

#floating-controls button {
    background: linear-gradient(90deg, #1abc9c, #16a085);
    color: white;
    border: none;
    padding: 8px 14px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

#floating-controls button:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 12px rgba(0,0,0,0.4);
}
    </style>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/html-to-image"></script>
</head>
<body>
    <div class="container">
        <div id="sidebar">
            <h2>📜 전투 기록</h2>
            <ul id="battle-history-list"></ul>
        </div>
        <!-- 토글 버튼 -->
        <button id="sidebar-toggle">📂 전투기록</button>

        <div id="floating-controls">
            <button id="start-battle">▶️ 전투 시작</button>
            <button id="end-battle">⏹ 전투 종료</button>
            <button id="capture-overview">📸 전투 개요 캡처</button>
            <button id="capture-detailed">📸 전투 상세 캡처</button>
        </div>

        <div class="capture-area">
            <div class="header">
                <h1>모비노기 전투분석기 V1.2</h1>
                <div class="battle-info">
                    <span>전투 시간: <span id="battle-time">0초</span></span>
                    <span>총 데미지: <span id="total-damage">0</span></span>
                    <span>RDPS: <span id="raid-dps">0</span></span>
                    <span>참여 플레이어: <span id="player-count">0</span></span>
                </div>
            </div>
            <!-- <h2 style="text-align: center;">📜 실시간 패킷 로그</h2>
            <div class="raw-logs" id="raw-logs">
                <pre id="log-output" style="max-height: 300px; overflow-y: auto; background: #111; color: #0f0; padding: 10px; font-size: 12px;"></pre>
            </div>           -->

            <div class="connection-status disconnected" id="connection-status">
                연결 끊김
            </div>
            
            <h2 style="text-align: center; color: #1abc9c;">👥 플레이어 데이터</h2>
            <div class="player-rankings" id="player-rankings">
                <div class="ranking-header">
                    <div>순위</div>
                    <div>플레이어</div>
                    <div>총 데미지 (DPS) - 기여도%</div>
                </div>
                <div class="no-data">
                    데미지 데이터를 기다리는 중...
                </div>
            </div>

            <div id="chart-wrapper" style="margin: 20px auto; max-width: 800px;">
            <h2 style="text-align: center; color: #1abc9c;">📈 전투 누적 데미지 추이</h2>

            <div id="chart-section">
                <canvas id="damageChart" width="800" height="400"></canvas>
            </div>

            <div id="chart-placeholder" style="
                display: none;
                text-align: center;
                color: #888;
                font-size: 1.2em;
                padding: 50px 0;
                background: #1a1a1a;
                border: 1px solid #333;
                border-radius: 6px;
            ">
                데미지 데이터를 기다리는 중...
            </div>
        </div>
        </div>
    </div>

    <script>
        let isBattleActive = false;
        let chartIntervalId = null;
        let displayIntervalId = null;
        let autoAnalyzeIntervalId = null;
        let inactivityIntervalId = null;
        let isPlaybackMode = false;

        let ws = null;
        let battleData = {};
        let startTime = 0;
        let lastUpdateTime = 0;
        let totalBattleDamage = 0;
        let expandedPlayers = new Set(); // Track which players have expanded skill breakdowns

        // Class detection mapping
        const classMapping = {
            'SwordMaster': { name: '검술', color: 'linear-gradient(90deg, #8B4513, #A0522D)' },
            'Arbalist': { name: '석궁사수', color: 'linear-gradient(90deg, #228B22, #32CD32)' },
            'FireMage': { name: '화법', color: 'linear-gradient(90deg, #FF4500, #FF6347)' },
            'IceMage': { name: '얼탱', color: 'linear-gradient(90deg, #4169E1, #87CEEB)' },
            'Fighter': { name: '격투가', color: 'linear-gradient(90deg, #DC143C, #B22222)' },
            'LongBowMan': { name: '장궁병', color: 'linear-gradient(90deg, #2E8B57, #3CB371)' },
            'Healer': { name: '힐러', color: 'linear-gradient(90deg, #FFD700, #FFA500)' },
            'ExpertWarrior': { name: '전사', color: 'linear-gradient(90deg, #696969, #808080)' },
            'GreatSwordWarrior': { name: '대검전사', color: 'linear-gradient(90deg, #4B0082, #6A5ACD)' },
            'HighThief': { name: '도적', color: 'linear-gradient(90deg, #2F4F4F, #708090)' },
            'DualBlades': { name: '듀블', color: 'linear-gradient(90deg, #8B008B, #DA70D6)' },
            'HighArcher': { name: '궁수', color: 'linear-gradient(90deg, #006400, #228B22)' },
            'HighMage': { name: '마법사', color: 'linear-gradient(90deg, #4B0082, #9400D3)' },
            'Priest': { name: '사제', color: 'linear-gradient(90deg, #F0F8FF, #E6E6FA)' },
            'Bard': { name: '음유시인', color: 'linear-gradient(90deg, #FF69B4, #FFB6C1)' },
            'Monk': { name: '수도사', color: 'linear-gradient(90deg, #CD853F, #D2691E)' },
            'Dancer': { name: '댄서', color: 'linear-gradient(90deg, #FF1493, #FF69B4)' },
            'BattleMusician': { name: '악사', color: 'linear-gradient(90deg, #9932CC, #BA55D3)' }
        };

        function detectPlayerClass(userData) {
            if (!userData.skills) return null;

            for (const skillName of Object.keys(userData.skills)) {
                for (const [classCode, classInfo] of Object.entries(classMapping)) {
                    if (skillName.includes(classCode)) {
                        return classCode;
                    }
                }
            }
            return null;
        }

        let processedLogsPerUser = {};

        // WebSocket connection
        function connectWebSocket() {
            try {
                ws = new WebSocket("ws://localhost:8000");


                ws.onopen = function(evt) {
                    console.log("웹소켓 연결됨");
                    updateConnectionStatus(true);
                };

                ws.onclose = function(evt) {
                    console.log("웹소켓 연결 해제됨");
                    updateConnectionStatus(false);
                    // Try to reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onmessage = function(evt) {
                    // logRawPacket(evt.data);
                    processDamageData(evt.data);
                    const parts = evt.data.split('|');
                    const entry = {
                        timestamp: parts[0],
                        userId: parts[1],
                        skill: parts[3]
                    };
                    saveRawLog(entry.userId, entry);
                };

                ws.onerror = function(evt) {
                    console.error("웹소켓 오류:", evt);
                    updateConnectionStatus(false);
                };
            } catch (error) {
                console.error("웹소켓 연결 실패:", error);
                updateConnectionStatus(false);
                setTimeout(connectWebSocket, 3000);
            }
        }

        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            if (connected) {
                statusElement.textContent = '연결됨';
                statusElement.className = 'connection-status connected';
            } else {
                statusElement.textContent = '연결 끊김';
                statusElement.className = 'connection-status disconnected';
            }
        }

        function processDamageData(data) {
            const parts = data.split('|');
            console.log(parts.length)
            if (parts.length !== 23) return;

            const timestamp = parseInt(parts[0]);
            const userId = parts[1];
            const target = parts[2];
            const skill = parts[3];
            const damage = parseInt(parts[5]);
            const critFlag = parseInt(parts[6]);
            const addHitFlag = parseInt(parts[7]);

            const unguardedFlag = parseInt(parts[8]);
            const breakFlag = parseInt(parts[9]);
            const firstHitFlag = parseInt(parts[10]);
            const defaultAttackFlag = parseInt(parts[11]);
            const multiAttackFlag = parseInt(parts[12]);
            const powerFlag = parseInt(parts[13]);
            const fastFlag = parseInt(parts[14]);

            const dotFlag = parseInt(parts[15]);
            const iceFlag = parseInt(parts[16]);
            const fireFlag = parseInt(parts[17]);
            const electricFlag = parseInt(parts[18]);
            const holyFlag = parseInt(parts[19]);
            const bleedFlag = parseInt(parts[20]);
            const poisonFlag = parseInt(parts[21]);
            const mindFlag = parseInt(parts[22]);

            const isDebuff = dotFlag || iceFlag || fireFlag || electricFlag || holyFlag || bleedFlag || poisonFlag || mindFlag;

            // Check for new battle (10+ second gap)
            if (lastUpdateTime === 0 || timestamp - lastUpdateTime > 10000) {
                startNewBattle(timestamp);
            }

            lastUpdateTime = timestamp;

            // Initialize user data if needed
            if (!battleData[userId]) {
                battleData[userId] = {
                    totalDamage: 0,
                    hitCount: 0,
                    critCount: 0,
                    addHitCount: 0,
                    skills: {}
                };
            }

            // Initialize skill data if needed
            if (!battleData[userId].skills[skill]) {
                battleData[userId].skills[skill] = {
                    damage: 0,
                    hits: 0,
                    crits: 0,
                    addHits: 0,
                    minDamage: damage,
                    maxDamage: damage,
                    avgDamage: damage,
                    count: 1
                };
            } else {
                const s = battleData[userId].skills[skill];
                s.minDamage = Math.min(s.minDamage, damage);
                s.maxDamage = Math.max(s.maxDamage, damage);
                s.count += 1;
                s.avgDamage = Math.round((s.avgDamage * (s.count - 1) + damage) / s.count);
            }

            const skillData = battleData[userId].skills[skill];

            // Update data
            battleData[userId].totalDamage += damage;
            skillData.damage += damage;

            if (!addHitFlag) {
                battleData[userId].hitCount += 1;
                skillData.hits += 1;
            }

            if (critFlag) {
                battleData[userId].critCount += 1;
                skillData.crits += 1;
            }

            if (addHitFlag) {
                battleData[userId].addHitCount += 1;
                skillData.addHits += 1;
            }

            if (unguardedFlag) skillData.unguardedHits = (skillData.unguardedHits || 0) + 1;
            if (breakFlag) skillData.breakHits = (skillData.breakHits || 0) + 1;
            if (firstHitFlag) skillData.firstHits = (skillData.firstHits || 0) + 1;
            if (defaultAttackFlag) skillData.defaultAttackHits = (skillData.defaultAttackHits || 0) + 1;
            if (multiAttackFlag) skillData.multiAttackHits = (skillData.multiAttackHits || 0) + 1;
            if (powerFlag) skillData.powerHits = (skillData.powerHits || 0) + 1;
            if (fastFlag) skillData.fastHits = (skillData.fastHits || 0) + 1;
            if (isDebuff) skillData.dotHits = (skillData.dotHits || 0) + 1;

            totalBattleDamage += damage;

            // Update processed logs
            if (!processedLogsPerUser[userId]) {
                processedLogsPerUser[userId] = [];
            }
            if (!processedLogsPerUser[userId]) processedLogsPerUser[userId] = [];

            processedLogsPerUser[userId].push({
                timestamp,
                damage
            });
        }

        function startNewBattle(timestamp) {
            console.log("새로운 전투 시작");
            isBattleActive = true;
            isPlaybackMode = false;

            battleData = {};
            startTime = timestamp;
            totalBattleDamage = 0;
            expandedPlayers.clear(); // Clear expanded state for new battle

            updateDisplay();

            if (chartIntervalId) clearInterval(chartIntervalId);
            chartIntervalId = setInterval(renderDamageChart, 5000);

            if (displayIntervalId) clearInterval(displayIntervalId);
            displayIntervalId = setInterval(updateDisplay, 1000);

            if (autoAnalyzeIntervalId) clearInterval(autoAnalyzeIntervalId);
            autoAnalyzeIntervalId = setInterval(() => {
                for (const userId in rawLogsPerUser) {
                    analyzeUserForAuto(userId);
                }
            }, 5000);

            if (inactivityIntervalId) clearInterval(inactivityIntervalId);
            inactivityIntervalId = setInterval(checkBattleInactivity, 3000);
        }

        function endBattle() {
            if (!isBattleActive) return;
            console.log("전투 종료");
            isBattleActive = false;

            if (chartIntervalId) {
                clearInterval(chartIntervalId);
                chartIntervalId = null;
            }
            if (displayIntervalId) {
                clearInterval(displayIntervalId);
                displayIntervalId = null;
            }
            if (autoAnalyzeIntervalId) {
                clearInterval(autoAnalyzeIntervalId);
                autoAnalyzeIntervalId = null;
            }
            if (inactivityIntervalId) {
                clearInterval(inactivityIntervalId);
                inactivityIntervalId = null;
            }
            saveBattleRecord();
        }

        const INACTIVITY_LIMIT = 10000;

        function checkBattleInactivity() {
            if (lastUpdateTime > 0 && Date.now() - lastUpdateTime > INACTIVITY_LIMIT) {
                endBattle();
            }
        }

        function updateChartVisibility() {
            if (!isBattleActive) return;  // ✅ 전투 종료 후엔 차트 갱신 안 함

            const chartSection = document.getElementById('chart-section');
            const placeholder = document.getElementById('chart-placeholder');

            const hasData = Object.values(processedLogsPerUser).some(logs => logs.length > 0);

            if (hasData) {
                chartSection.style.display = 'block';
                placeholder.style.display = 'none';
                renderDamageChart();  // ✅ 전투 중일 때만 호출
            } else {
                chartSection.style.display = 'none';
                placeholder.style.display = 'block';
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
            }
        }

        function updateDisplay() {
            updateBattleInfo();
            updatePlayerRankings();
            updateChartVisibility();
        }

        function updateBattleInfo() {
            const battleTime = lastUpdateTime > 0 ? Math.floor((lastUpdateTime - startTime) / 1000) : 0;
            const playerCount = Object.keys(battleData).length;

            // Calculate RDPS (sum of DPS of players with detected classes only)
            let raidDps = 0;
            let detectedPlayerCount = 0;

            if (battleTime > 0) {
                for (const [userId, userData] of Object.entries(battleData)) {
                    const detectedClass = detectPlayerClass(userData);
                    if (detectedClass && classMapping[detectedClass]) {
                        const playerDps = Math.floor(userData.totalDamage / battleTime);
                        raidDps += playerDps;
                        detectedPlayerCount++;
                    }
                }
            }

            document.getElementById('battle-time').textContent = `${battleTime}초`;
            document.getElementById('total-damage').textContent = totalBattleDamage.toLocaleString();
            document.getElementById('raid-dps').textContent = raidDps.toLocaleString();
            document.getElementById('player-count').textContent = detectedPlayerCount;
        }

        function updatePlayerRankings() {
            const container = document.getElementById('player-rankings');

            if (Object.keys(battleData).length === 0) {
                container.innerHTML = `
                    <div class="ranking-header">
                        <div>순위</div>
                        <div>플레이어</div>
                        <div>데미지 (DPS)</div>
                    </div>
                    <div class="no-data">데미지 데이터를 기다리는 중...</div>
                `;
                return;
            }

            // Sort players by total damage
            const sortedPlayers = Object.entries(battleData)
                .sort(([,a], [,b]) => b.totalDamage - a.totalDamage);

            const maxDamage = sortedPlayers.length > 0 ? sortedPlayers[0][1].totalDamage : 1;
            const battleTime = lastUpdateTime > 0 ? (lastUpdateTime - startTime) / 1000 : 1;

            let html = `
                <div class="ranking-header">
                    <div>순위</div>
                    <div>플레이어</div>
                    <div>데미지 (DPS)</div>
                </div>
            `;

            let displayedPlayerIndex = 0;
            sortedPlayers.forEach(([userId, userData]) => {
                // Detect player class
                const detectedClass = detectPlayerClass(userData);

                // Only display players whose class has been detected
                if (!detectedClass || !classMapping[detectedClass]) {
                    return; // Skip this player
                }

                const playerDps = Math.floor(userData.totalDamage / battleTime);
                const playerPercentage = ((userData.totalDamage / totalBattleDamage) * 100).toFixed(1);
                const totalHits = userData.hitCount + userData.addHitCount;
                const critRate = totalHits > 0 ? ((userData.critCount / totalHits) * 100).toFixed(1) : 0;
                const barWidth = (userData.totalDamage / maxDamage) * 100;
                const timingStat = userTimingStats[userId];
                const timingInfo = timingStat ? `<div class="timing-stats"> 스킬 평균간격: ${timingStat.avg}ms / 편차: ${timingStat.std}</div>` : '';


                const barColor = classMapping[detectedClass].color;
                const className = classMapping[detectedClass].name;


                const rankClass = displayedPlayerIndex < 3 ? `rank-${displayedPlayerIndex + 1}` : '';
                const displayName = `${className} ${userId.substring(0, 8)}`;

                html += `
                    <div class="player-bar" onclick="toggleSkillBreakdown('${userId}')">
                        <div class="player-bar-fill" style="width: ${barWidth}%; background: ${barColor};"></div>
                        <div class="player-bar-content">
                            <div class="rank-section">
                                <div class="rank-number ${rankClass}">${displayedPlayerIndex + 1}</div>
                            </div>
                            <div class="player-name">
                                ${displayName} ${timingInfo}

                            </div>
                            <div class="stat-value damage-value">${userData.totalDamage.toLocaleString()} (${playerDps.toLocaleString()}) – ${playerPercentage}%</div>
                        </div>
                    </div>
                    <div class="skill-breakdown ${expandedPlayers.has(userId) ? 'show' : ''}" id="skills-${userId}">
                        <div class="skill-breakdown-header">유저 ${userId.substring(0, 8)} - 스킬 상세</div>
                        ${generateSkillBreakdown(userId, userData)}
                    </div>
                `;

                displayedPlayerIndex++;
            });

            container.innerHTML = html;

            // Remove updating animation after a short delay
            setTimeout(() => {
                document.querySelectorAll('.updating').forEach(el => {
                    el.classList.remove('updating');
                });
            }, 500);
        }

        function generateSkillBreakdown(userId, userData) {
            if (!userData.skills || Object.keys(userData.skills).length === 0) {
                return '<div style="color: #7f8c8d; text-align: center; padding: 20px;">스킬 데이터가 없습니다.</div>';
            }

            const sortedSkills = Object.entries(userData.skills)
                .sort(([,a], [,b]) => b.damage - a.damage);

            const maxSkillDamage = sortedSkills.length > 0 ? sortedSkills[0][1].damage : 1;
            const battleTime = lastUpdateTime > 0 ? (lastUpdateTime - startTime) / 1000 : 1;

            let skillHtml = '';
            sortedSkills.forEach(([skillName, skillData], skillIndex) => {
                const skillPercentage = ((skillData.damage / userData.totalDamage) * 100).toFixed(1);
                const skillDps = Math.floor(skillData.damage / battleTime);
                const skillTotalHits = skillData.hits + skillData.addHits;
                const skillCritRate = skillTotalHits > 0 ? ((skillData.crits / skillTotalHits) * 100).toFixed(1) : 0;
                const addHitRate = skillData.hits > 0 ? ((skillData.addHits / skillData.hits) * 100).toFixed(1) : 0;
                const barWidth = (skillData.damage / maxSkillDamage) * 100;
                const min = skillData.minDamage || 0;
                const max = skillData.maxDamage || 0;
                const avg = skillData.avgDamage || 0;

                const rate = (v) => skillTotalHits > 0 ? ((v / skillTotalHits) * 100).toFixed(1) : '0.0';
                const unguardedRate = rate(skillData.unguardedHits || 0);
                const breakRate = rate(skillData.breakHits || 0);
                const firstHitRate = rate(skillData.firstHits || 0);
                const defaultAttackRate = rate(skillData.defaultAttackHits || 0);
                const multiAttackRate = rate(skillData.multiAttackHits || 0);
                const powerRate = rate(skillData.powerHits || 0);
                const fastRate = rate(skillData.fastHits || 0);
                const dotRate = rate(skillData.dotHits || 0);

                let skillBarClass = 'skill-item-fill';
                if (skillIndex === 0) skillBarClass += ' top-skill';
                else if (skillCritRate > 30) skillBarClass += ' crit-heavy';

                skillHtml += `
                    <div class="skill-item">
                        <div class="skill-item-bar">
                            <div class="${skillBarClass}" style="width: ${barWidth}%"></div>
                            <div class="skill-item-info">
                                <span class="skill-name">${skillName}</span>
                                <span class="skill-compact-stats">
                                    타수 ${skillData.hits} | 크리 ${skillCritRate}% | 추가타율 ${addHitRate}% |
                                    ${skillData.damage.toLocaleString()} 
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="skill-item-stats-block horizontal-layout">
                        <div class="skill-basic-stats">
                            <span class="highlight-percent">[${skillPercentage}%]</span>
                            평균 ${avg.toLocaleString()} / 최소 ${min.toLocaleString()} / 최대 ${max.toLocaleString()}
                        </div>
                        <div class="skill-extra-stats">
                            <table class="stats-table">
                                <tr>
                                    <td>무방비율</td><td>${unguardedRate}%</td>
                                    <td>브레이크율</td><td>${breakRate}%</td>
                                    <td>멀티히트율</td><td>${multiAttackRate}%</td>
                                </tr>
                                <tr>
                                    <td>강타율</td><td>${powerRate}%</td>
                                    <td>연타율</td><td>${fastRate}%</td>
                                    <td>상태이상율</td><td>${dotRate}%</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                `;
            });

            return skillHtml;
        }

        function toggleSkillBreakdown(userId) {
            const skillBreakdown = document.getElementById(`skills-${userId}`);
            if (!skillBreakdown) return;

            if (expandedPlayers.has(userId)) {
                // Player is currently expanded, so collapse it
                expandedPlayers.delete(userId);
                skillBreakdown.classList.remove('show');
            } else {
                // Collapse all other breakdowns first
                document.querySelectorAll('.skill-breakdown.show').forEach(el => {
                    el.classList.remove('show');
                });
                expandedPlayers.clear();

                // Expand this player's breakdown
                expandedPlayers.add(userId);

                // Update the breakdown content with latest data
                const userData = battleData[userId];
                if (userData) {
                    skillBreakdown.innerHTML = `
                        <div class="skill-breakdown-header">유저 ${userId.substring(0, 8)} - 스킬 상세</div>
                        ${generateSkillBreakdown(userId, userData)}
                    `;
                }

                skillBreakdown.classList.add('show', 'animate');

                // Remove animate class after animation completes
                setTimeout(() => {
                    skillBreakdown.classList.remove('animate');
                }, 300);
            }
        }

        function logRawPacket(packet) {
            const logElement = document.getElementById('log-output');
            if (!logElement) return;

            const timeStr = new Date().toLocaleTimeString();
            const safePacket = packet.replace(/</g, '&lt;').replace(/>/g, '&gt;');  // 보안 처리

            logElement.textContent += `[${timeStr}] ${safePacket}\n`;

            // 로그가 너무 많아지면 오래된 부분 삭제
            if (logElement.textContent.split('\n').length > 200) {
                logElement.textContent = logElement.textContent.split('\n').slice(-200).join('\n');
            }

            logElement.scrollTop = logElement.scrollHeight;
        }

        function groupActions(rawLogs) {
            const grouped = [];
            let current = null;

            for (let i = 0; i < rawLogs.length; i++) {
                const entry = rawLogs[i];
                const skillName = entry.skill;
                const timestamp = parseInt(entry.timestamp);

                if (skillName.startsWith("DOT_")) continue;
                if (skillName.startsWith("Idle")) continue;

                const isMelee = skillName.includes("DefaultAttack");
                const type = isMelee ? "melee" : "skill";

                if (current && current.name === skillName && timestamp - current.lastTimestamp < 300) {
                    current.hits++;
                    current.lastTimestamp = timestamp;
                } else {
                    if (current) grouped.push(current);
                    current = {
                        type,
                        name: skillName,
                        timestamp,
                        lastTimestamp: timestamp,
                        hits: 1
                    };
                }
            }

            if (current) grouped.push(current);
            return grouped;
        }

        function mean(arr) {
            return arr.reduce((sum, v) => sum + v, 0) / arr.length;
        }

        function stdDev(arr) {
            const avg = mean(arr);
            return Math.sqrt(arr.reduce((sum, v) => sum + (v - avg) ** 2, 0) / arr.length);
        }

        
        function isAutoTimingPattern(actions, minCount = 10) {
            if (actions.length < minCount) return false;

            const timeDiffs = [];
            for (let i = 1; i < actions.length; i++) {
                const delta = actions[i].timestamp - actions[i - 1].timestamp;
                if (delta > 0 && delta < 10000) {
                    timeDiffs.push(delta);
                }
            }

            const avg = mean(timeDiffs);
            const dev = stdDev(timeDiffs);
            return (timeDiffs.length >= minCount && 
                    timeDiffs.every(diff => Math.abs(diff - avg) < dev * 0.5));
        }

        let rawLogsPerUser = {};
        const suspectedAutoUsers = new Set();

        let userTimingStats = {}; // 전역에 추가

        function analyzeUserForAuto(userId) {
            const raw = rawLogsPerUser[userId];
            if (!raw || raw.length < 10) return;

            const grouped = groupActions(raw);
            const timeDiffs = [];

            for (let i = 1; i < grouped.length; i++) {
                const delta = grouped[i].timestamp - grouped[i - 1].timestamp;
                if (delta > 0 && delta < 10000) {
                    timeDiffs.push(delta);
                }
            }

            const avg = mean(timeDiffs);
            const dev = stdDev(timeDiffs);

            // 저장
            userTimingStats[userId] = {
                avg: avg.toFixed(1),
                std: dev.toFixed(1),
                count: timeDiffs.length
            };
        }


        function saveRawLog(userId, entry) {
            if (!isBattleActive) return;
            if (!rawLogsPerUser[userId]) rawLogsPerUser[userId] = [];
            rawLogsPerUser[userId].push(entry);

            // 최근 30초까지만 유지
            const now = Date.now();
            rawLogsPerUser[userId] = rawLogsPerUser[userId].filter(e => now - parseInt(e.timestamp) < 30000);
        }

        function extractFirstColorFromGradient(gradient) {
            const match = gradient.match(/#(?:[0-9a-fA-F]{3}){1,2}/);
            return match ? match[0] : '#cccccc'; // fallback
        }

        const userChartColors = {};  // 유저별 고정 색상 저장용

        function extractFirstColorFromGradient(gradient) {
            const match = gradient.match(/#(?:[0-9a-fA-F]{3,6})/);
            return match ? match[0] : '#cccccc';
        }

        function getUserChartColor(userId, userData) {
            if (userChartColors[userId]) return userChartColors[userId];

            const classCode = detectPlayerClass(userData);
            const classInfo = classMapping[classCode];
            const color = classInfo ? extractFirstColorFromGradient(classInfo.color) : '#999999';

            userChartColors[userId] = color;
            return color;
        }

        let chartInstance = null;

        function renderDamageChart() {
            const canvas = document.getElementById('damageChart');
            if (!canvas || !startTime) return;

            const ctx = canvas.getContext('2d');
            const now = Date.now();
            let elapsedSec;
            if (isPlaybackMode) {
                // 📌 재생 모드에서는 기록된 전투 길이로 고정
                elapsedSec = Math.floor((lastUpdateTime - startTime) / 1000);
            } else {
                // 실시간 모드에서는 현재 시간 기준
                const now = Date.now();
                elapsedSec = Math.floor((now - startTime) / 1000);
            }
            if (elapsedSec <= 0) return;

            const labels = Array.from({ length: elapsedSec + 1 }, (_, i) => `${i}s`);
            const datasets = [];

            for (const [userId, logs] of Object.entries(processedLogsPerUser)) {
                const userData = battleData[userId] || {};
                const classCode = detectPlayerClass(userData);
                if (!classCode || !classMapping[classCode]) continue;  // 알 수 없는 유저는 무시

                const damageTimeline = new Array(elapsedSec + 1).fill(0);

                logs.forEach(entry => {
                    const time = Math.floor((entry.timestamp - startTime) / 1000);
                    if (time >= 0 && time <= elapsedSec) {
                        damageTimeline[time] += entry.damage;
                    }
                });

                for (let i = 1; i <= elapsedSec; i++) {
                    damageTimeline[i] += damageTimeline[i - 1];
                }

                const className = classMapping[classCode].name;
                const labelName = `${className} ${userId.substring(0, 8)}`;
                const color = getUserChartColor(userId, userData);

                datasets.push({
                    label: labelName,
                    data: damageTimeline,
                    borderColor: color,
                    tension: 0.1,
                    fill: false
                });
            }

            if (chartInstance) chartInstance.destroy();

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    animation: false,
                    plugins: {
                        title: {
                            display: true,
                            text: '전투 시간 기준 유저별 누적 데미지'
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function saveBattleRecord() {
            if (isPlaybackMode) {
                console.log("[INFO] 기록 재생 중이므로 저장하지 않음");
                return;
            }

            const timestamp = new Date().toISOString();
            const durationSec = Math.floor((lastUpdateTime - startTime) / 1000);
            const playerCount = Object.entries(battleData).filter(([userId, userData]) => {
                    const detectedClass = detectPlayerClass(userData);
                    return detectedClass && classMapping[detectedClass];
                }).length;


            const record = {
                timestamp,
                battleData,
                rawLogsPerUser,
                processedLogsPerUser, // ✅ 추가
                startTime,
                lastUpdateTime,
                userTimingStats,
                summary: {
                    duration: durationSec,
                    playerCount: playerCount
                }
            };

            let history = JSON.parse(localStorage.getItem('battleHistory') || '[]');
            history.push(record);

            if (history.length > 20) {
                history = history.slice(-20);
            }

            localStorage.setItem('battleHistory', JSON.stringify(history));
            updateHistorySidebar();
        }


        function updateHistorySidebar() {
            const history = JSON.parse(localStorage.getItem('battleHistory') || '[]');
            const list = document.getElementById('battle-history-list');
            list.innerHTML = '';

            history.forEach((record, index) => {
                const date = new Date(record.timestamp);
                const dateStr = date.toLocaleDateString();
                const timeStr = date.toLocaleTimeString();

                const duration = record.summary?.duration || 0;
                const playerCount = Object.entries(record.battleData).filter(([userId, userData]) => {
                    const detectedClass = detectPlayerClass(userData);
                    return detectedClass && classMapping[detectedClass];
                }).length;
                
                const li = document.createElement('li');
                li.innerHTML = `
                    <span style="flex:1; cursor:pointer;" onclick="loadBattleRecord(${index})">
                        전투 ${index + 1} - ${playerCount}인 / ${duration}초<br>${dateStr} ${timeStr}
                    </span>
                    <button onclick="deleteBattleRecord(${index})" style="margin-left: 10px; background: none; border: none; color: red; cursor: pointer;">
                        🗑
                    </button>
                `;
                li.style.display = 'flex';
                li.style.justifyContent = 'space-between';
                li.style.alignItems = 'center';
                list.appendChild(li);
            });
            if (history.length === 0) {
                list.innerHTML = '<li>전투 기록이 없습니다.</li>';
            }
        }


        function loadBattleRecord(index) {
            const history = JSON.parse(localStorage.getItem('battleHistory') || '[]');
            if (!history[index]) return;

            const record = history[index];
            battleData = record.battleData;
            rawLogsPerUser = record.rawLogsPerUser;
            processedLogsPerUser = record.processedLogsPerUser || {};
            userTimingStats = record.userTimingStats || {};
            startTime = record.startTime;
            lastUpdateTime = record.lastUpdateTime;
            totalBattleDamage = 0;
            expandedPlayers.clear();

            for (const user of Object.values(battleData)) {
                totalBattleDamage += user.totalDamage || 0;
            }

            // 과거 기록은 종료된 상태로 간주
            isBattleActive = false;
            isPlaybackMode = true;

            // 주기적 업데이트 중단
            clearInterval(chartIntervalId);
            clearInterval(displayIntervalId);
            clearInterval(autoAnalyzeIntervalId);
            clearInterval(inactivityIntervalId);

            updateDisplay();
            renderDamageChart();
        }


        function deleteBattleRecord(index) {
            let history = JSON.parse(localStorage.getItem('battleHistory') || '[]');
            history.splice(index, 1);
            localStorage.setItem('battleHistory', JSON.stringify(history));
            updateHistorySidebar();
        }


        // Toggle sidebar visibility
        document.addEventListener('DOMContentLoaded', () => {
            updateHistorySidebar();
            const sidebar = document.getElementById('sidebar');
            const toggleButton = document.getElementById('sidebar-toggle');

            toggleButton.addEventListener('click', () => {
                const collapsed = sidebar.classList.toggle('hidden');
                document.body.classList.toggle('sidebar-collapsed', collapsed);

                // 버튼 아이콘 변경
                toggleButton.textContent = collapsed ? '📂 전투기록' : '❌ 닫기';
            });

            // 초기 상태 설정
            if (sidebar.classList.contains('hidden')) {
                document.body.classList.add('sidebar-collapsed');
                toggleButton.textContent = '📂 전투기록';
            } else {
                toggleButton.textContent = '❌ 닫기';
            }
        });

        function captureBattleView(showAllSkills = false) {
            const captureTarget = document.querySelector('.capture-area');
            const skillElements = document.querySelectorAll('.skill-breakdown');
            const originallyExpanded = [];

            // 💡 스킬 breakdown 펼치기
            if (showAllSkills) {
                skillElements.forEach(el => {
                    const wasExpanded = el.classList.contains('show');
                    originallyExpanded.push(wasExpanded);
                    el.classList.add('show');
                });
            }

            // 💡 렌더링 대기 후 캡처
            setTimeout(() => {
                htmlToImage.toPng(captureTarget)
                    .then(dataUrl => {
                        const link = document.createElement('a');
                        link.download = `battle_capture_${Date.now()}.png`;
                        link.href = dataUrl;
                        link.click();

                        // 💡 원래대로 복원
                        if (showAllSkills) {
                            skillElements.forEach((el, idx) => {
                                if (!originallyExpanded[idx]) {
                                    el.classList.remove('show');
                                }
                            });
                        }
                    })
                    .catch(error => {
                        console.error("html-to-image 캡처 오류:", error);
                    });
            }, 100); // 충분히 렌더링 대기
        }



        function handleManualBattleStart() {
            const now = Date.now();
            startNewBattle(now);
            console.log("🟢 수동 전투 시작됨");

            // 버튼 상태 업데이트
            document.getElementById('start-battle').disabled = true;
            document.getElementById('end-battle').disabled = false;
        }

        function handleManualBattleEnd() {
            endBattle();
            console.log("🔴 수동 전투 종료됨");

            document.getElementById('start-battle').disabled = false;
            document.getElementById('end-battle').disabled = true;
        }
        document.getElementById('start-battle').addEventListener('click', handleManualBattleStart);
        document.getElementById('end-battle').addEventListener('click', handleManualBattleEnd);
        document.getElementById('capture-overview').addEventListener('click', () => {
            captureBattleView(false);  // skill breakdown 안 펼침
        });
        document.getElementById('capture-detailed').addEventListener('click', () => {
            captureBattleView(true);  // skill breakdown 전체 펼침
        });



        // Initialize
        connectWebSocket();

        setInterval(() => {
            for (const userId in rawLogsPerUser) {
                analyzeUserForAuto(userId);
            }
        }, 5000);
    </script>
</body>
</html>
